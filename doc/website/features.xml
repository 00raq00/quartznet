<?xml version="1.0"?>
<document>
	<properties>
		<title>Features</title>
	</properties>
	<body>
		<intro>
		</intro>

		<section>
			<title>Quartz.NET Features</title>
		
			<section>
				<title>Runtime Environments</title>
				<ul>
					<li>Quartz.NET can run embedded within another free standing application</li>
					<li>Quartz.NET can run as a stand-alone program (within its own .NET virtual machine instance), to be used via .NET Remoting</li>
					<li>Quartz.NET can be instantiated as a cluster of stand-alone programs (with load-balance and fail-over capabilities)</li>
				</ul>
			</section>
			
			<section>
				<title>Job Scheduling</title>
				<p>
					Jobs are scheduled to run when a given Trigger occurs. Triggers can be created with nearly any combination of the following directives:
				</p>
				<ul>
					<li>at a certain time of day (to the millisecond)</li>
					<li>on certain days of the week</li>
					<li>on certain days of the month</li>
					<li>on certain days of the year</li>
					<li>not on certain days listed within a registered Calendar (such as business holidays)</li>
					<li>repeated a specific number of times</li>
					<li>repeated until a specific time/date</li>
					<li>repeated indefinitely</li>
					<li>repeated with a delay interval</li>
				</ul>
				<p>
					Jobs are given names by their creator and can also be organized into named groups. 
					Triggers may also be given names and placed into groups, in order to easily organize them within the scheduler. 
					Jobs can be added to the scheduler once, but registered with multiple Triggers. 
				</p>
			</section>
			<section>
				<title>Job Execution</title>
				<ul>
					<li>Jobs can be any .NET class that implements the simple IJob interface, leaving infinite possibilities for the work Jobs can perform.</li>
					<li>Job class instances can be instantiated by Quartz.NET, or by your application's framework.</li>
					<li>
						When a Trigger occurs, the scheduler notifies zero or more .NET objects implementing the JobListener and TriggerListener interfaces.
						These listeners are also notified after the Job has executed.
					</li>
					<li>
						As Jobs are completed, they return a JobCompletionCode which informs the scheduler of success or failure. 
						The JobCompletionCode can also instruct the scheduler of any actions it should take based on the success/fail code - such as immediate re-execution of the Job.
					</li>
				</ul>
			</section>

			<section>
				<title>Job Persistence</title>
				<ul>
					<li>
						The design of Quartz.NET includes a IJobStore interface that can be implemented to provide various mechanisms for the storage of jobs.
					</li>
					<li>
						With the use of the included AdoJobStore, all Jobs and Triggers configured as "non-volatile" are stored in a relational database via ADO.NET.
					</li>
					<li>
						With the use of the included RAMJobStore, all Jobs and Triggers are stored in RAM and therefore do not persist between program executions -
						but this has the advantage of not requiring an external database.
					</li>
				</ul>
			</section>
				
			<section>
				<title>Clustering</title>
				<br />
				<ul>
					<li>Fail-over.</li>
					<li>Load balancing.</li>
				</ul>
			</section>

			<section>
				<title>Listeners &amp; Plug-Ins</title>
				<br />
				<ul>
					<li>Applications can catch scheduling events to monitor or control job/trigger behavior by implementing one or more listener interfaces.</li>
					<li>The Plug-In mechanism can be used add functionality to Quartz, such keeping a history of job executions, or loading job and trigger definitions from a file.</li>
					<li>Quartz ships with a number of "factory built" plug-ins and listeners.</li>
				</ul>
			</section>
		</section>
	</body>
</document>
